///////////////////////////////////////////////////////////////////////////////
//
/// \file       test_lzma_raw.c
/// \brief      Tests liblzma raw API functions from
///             src/liblzma/api/lzma/filter.h
//
//  Author:     Jia Tan
//
//  This file has been put into the public domain.
//  You can do whatever you want with this file.
//
///////////////////////////////////////////////////////////////////////////////

#include "liblzma_tests.h"
#include "test_utils.h"
#include "test_lzma_filter_utils.h"
#include <stdlib.h>

#define LZMA_FILTER_RAW_CHUNK_SIZE 4096

// Hardcoding expected memusage amounts in order to detect
// unexpected changes to memusage
// Used in test_lzma_raw_encoder_memusage and
// test_lzma_raw_decoder_memusage
#define EXPECTED_LZMA1_ENCODER_MEMUSAGE 63739583
#define EXPECTED_LZMA2_ENCODER_MEMUSAGE 64067431
#define EXPECTED_LZMA1_DECODER_MEMUSAGE 8455392
#define EXPECTED_LZMA2_DECODER_MEMUSAGE 8455576

// Creating these globals reduce recomputation
static uint8_t* test_file_data;
static size_t test_file_data_size;
static const char* test_data_filename =
			"files/lzma_filters/raw_original.txt";

static uint8_t* test_lzma1_raw_encoded_data;
static size_t test_lzma1_raw_encoded_data_size;
static const char* test_lzma1_raw_encoded_filename =
			"files/lzma_filters/lzma1_raw";

static uint8_t* test_lzma2_raw_encoded_data;
static size_t test_lzma2_raw_encoded_data_size;
static const char* test_lzma2_raw_encoded_filename =
			"files/lzma_filters/lzma2_raw";

static uint8_t* test_lzma1_alone_raw_encoded_data;
static size_t test_lzma1_alone_raw_encoded_data_size;
static const char* test_lzma1_alone_raw_encoded_filename =
			"files/lzma_filters/lzma1_alone_raw";

static lzma_filter lzma1_alone_filters[2] = {
	{
		.id = LZMA_FILTER_LZMA1,
		.options = &lzma1_ops
	},
	{
		.id = LZMA_VLI_UNKNOWN,
		.options = NULL
	}
};

static void
test_lzma_raw_encoder_memusage(void)
{
#ifdef TEST_FILTER_CHAIN_ENCODER_INVALID
	// Invalid filters should error out with UINT64_MAX
	assert_ulong_equal(lzma_raw_encoder_memusage(invalid_filters),
				UINT64_MAX);
#endif
#ifdef TEST_FILTER_CHAIN_ENCODER_LZMA1
	// Filters memusage should be non-zero and < UINT64_MAX
	uint64_t lzma1_memusage = lzma_raw_encoder_memusage(lzma1_filters);
	assert_true(lzma1_memusage > 0 && lzma1_memusage < UINT64_MAX);
	// Check against hard coded memusage value
	assert_ulong_equal(EXPECTED_LZMA1_ENCODER_MEMUSAGE, lzma1_memusage);
#endif
#ifdef TEST_FILTER_CHAIN_ENCODER_LZMA2
	uint64_t lzma2_memusage = lzma_raw_encoder_memusage(lzma2_filters);
	assert_true(lzma2_memusage > 0 && lzma2_memusage < UINT64_MAX);
	// Check against hard coded memusage value
	assert_ulong_equal(EXPECTED_LZMA2_ENCODER_MEMUSAGE, lzma2_memusage);
#endif
}


static void
test_lzma_raw_decoder_memusage(void)
{
#ifdef TEST_FILTER_CHAIN_DECODER_INVALID
	// Invalid filters should error out with UINT64_MAX
	assert_ulong_equal(lzma_raw_decoder_memusage(invalid_filters),
				UINT64_MAX);
#endif
#ifdef TEST_FILTER_CHAIN_DECODER_LZMA1
	// Filters memusage should be non-zero and < UINT64_MAX
	uint64_t lzma1_memusage = lzma_raw_decoder_memusage(lzma1_filters);
	assert_true(lzma1_memusage > 0 && lzma1_memusage < UINT64_MAX);
	// Check against hard coded memusage value
	assert_ulong_equal(EXPECTED_LZMA1_DECODER_MEMUSAGE, lzma1_memusage);
#endif
#ifdef TEST_FILTER_CHAIN_DECODER_LZMA2
	uint64_t lzma2_memusage = lzma_raw_decoder_memusage(lzma2_filters);
	assert_true(lzma2_memusage > 0 && lzma2_memusage < UINT64_MAX);
	// Check against hard coded memusage value
	assert_ulong_equal(EXPECTED_LZMA2_DECODER_MEMUSAGE, lzma2_memusage);
#endif
}


// Helper function for both test_lzma_raw_encoder and test_lzma_raw_decoder
// Applies lzma_code on data from original_filename into a buffer until
// all of the data has been processed
// Then it will compare the buffer to contents from precomputed_filename
// Files in files/lzma_filters/ contain small text files and corresponding
// LZMA1 and LZMA2 raw encoded files generated by
// the XZ command line interface
static void
raw_coder_and_verify(const uint8_t* input_data,
			size_t input_data_size,
			const uint8_t* expected_output,
			size_t expected_output_size,
			lzma_stream *strm)
{
	// Allocate raw buffer one chunk at a time
	int chunks_used = 1;
	uint8_t* raw_buffer = (uint8_t*) malloc(LZMA_FILTER_RAW_CHUNK_SIZE);
	assert_true(raw_buffer != NULL);

	strm->next_in = input_data;
	strm->avail_in = input_data_size;
	strm->next_out = raw_buffer;
	strm->avail_out = LZMA_FILTER_RAW_CHUNK_SIZE;

	lzma_action action = LZMA_RUN;
	// Loop until LZMA_STREAM_END or error returned
	while(1) {
		if(strm->avail_in == 0) {
			action = LZMA_FINISH;
		}

		lzma_ret ret = lzma_code(strm, action);

		if(ret == LZMA_STREAM_END) {
			break;
		}

		if(strm->avail_out == 0) {
			chunks_used++;
			raw_buffer = realloc(raw_buffer,
						chunks_used *
						LZMA_FILTER_RAW_CHUNK_SIZE);
			assert_true(raw_buffer != NULL);
			strm->next_out = raw_buffer +
					((chunks_used - 1) *
					LZMA_FILTER_RAW_CHUNK_SIZE);
			strm->avail_out = LZMA_FILTER_RAW_CHUNK_SIZE;
		}

		assert_int_equal(ret, LZMA_OK);
	}

	// Compare pre-computed to output
	assert_n_array_equal(expected_output, raw_buffer,
				expected_output_size);
	free(raw_buffer);
}


static void
test_lzma_raw_encoder(void)
{
#ifdef TEST_FILTER_CHAIN_ENCODER_INVALID
	lzma_stream strm_error = LZMA_STREAM_INIT;
	// Verify errors are returned for invalid filters
	assert_int_equal(lzma_raw_encoder(&strm_error, invalid_filters),
						LZMA_OPTIONS_ERROR);
#endif
#ifdef TEST_FILTER_CHAIN_ENCODER_LZMA1
	// Verify initialization of LZMA1 raw encoder
	lzma_stream lzma1_raw_strm = LZMA_STREAM_INIT;
	assert_int_equal(lzma_raw_encoder(&lzma1_raw_strm, lzma1_filters),
						LZMA_OK);
	raw_coder_and_verify(test_file_data, test_file_data_size,
				test_lzma1_raw_encoded_data,
				test_lzma1_raw_encoded_data_size,
				&lzma1_raw_strm);
#endif

#ifdef TEST_FILTER_CHAIN_ENCODER_LZMA2
	// Verify initialilzation of LZMA2 raw encoder
	lzma_stream lzma2_raw_strm = LZMA_STREAM_INIT;
	assert_int_equal(lzma_raw_encoder(&lzma2_raw_strm, lzma2_filters),
						LZMA_OK);
	raw_coder_and_verify(test_file_data, test_file_data_size,
				test_lzma2_raw_encoded_data,
				test_lzma2_raw_encoded_data_size,
				&lzma2_raw_strm);
#endif
}


static void
test_lzma_raw_decoder(void)
{
#ifdef TEST_FILTER_CHAIN_DECODER_INVALID
	lzma_stream strm_error = LZMA_STREAM_INIT;
	// Verify errors are returned for invalid filters
	assert_int_equal(lzma_raw_decoder(&strm_error, invalid_filters),
						LZMA_OPTIONS_ERROR);
#endif
#ifdef TEST_FILTER_CHAIN_DECODER_LZMA1
	// Verify initialization of lzma1 raw decoder
	lzma_stream lzma1_raw_strm = LZMA_STREAM_INIT;
	assert_int_equal(lzma_raw_decoder(&lzma1_raw_strm, lzma1_filters),
						LZMA_OK);
	raw_coder_and_verify(test_lzma1_raw_encoded_data,
				test_lzma1_raw_encoded_data_size,
				test_file_data, test_file_data_size,
				&lzma1_raw_strm);
#endif
#ifdef TEST_FILTER_CHAIN_DECODER_LZMA2
	// Verify initialization of lzma2 raw decoder
	lzma_stream lzma2_raw_strm = LZMA_STREAM_INIT;
	assert_int_equal(lzma_raw_decoder(&lzma2_raw_strm, lzma2_filters),
						LZMA_OK);

	raw_coder_and_verify(test_lzma2_raw_encoded_data,
				test_lzma2_raw_encoded_data_size,
				test_file_data, test_file_data_size,
				&lzma2_raw_strm);
#endif
}


// Helper function for the test_lzma_raw_buffer_encode function
// Used to encode both LZMA1 and LZMA2 raw data and compare the
// results to precomputed files in files/lzma_filters/
static void
raw_buffer_encode_and_verify(const uint8_t* input_data,
			size_t input_data_size,
			const uint8_t* expected_output,
			size_t expected_output_size,
			lzma_filter* filters)
{
	// lzma_stream_buffer_bound should return more than what we need
	// for the raw buffer, but the extra space will not hurt
	size_t upperbound_out_buf_size =
				lzma_stream_buffer_bound(input_data_size);

	uint8_t* out_buffer = (uint8_t*) malloc(upperbound_out_buf_size);
	assert_true(out_buffer != NULL);
	size_t out_pos = 0;

	lzma_ret ret = lzma_raw_buffer_encode(filters, NULL,
				input_data, input_data_size, out_buffer,
				&out_pos, upperbound_out_buf_size);
	assert_int_equal(ret, LZMA_OK);

	// Compare pre-computed to encoded
	assert_n_array_equal(expected_output, out_buffer,
				expected_output_size);
	free(out_buffer);
}


static void
test_lzma_raw_buffer_encode(void)
{
#ifdef TEST_FILTER_CHAIN_ENCODER_INVALID
	uint8_t invalid_buf_in[LZMA_FILTER_RAW_CHUNK_SIZE];
	uint8_t invalid_buf_out[LZMA_FILTER_RAW_CHUNK_SIZE];
	size_t out_pos = 0;
	// First use invalid filters to be sure they force
	// the LZMA_OPTIONS_ERROR as expected
	assert_int_equal(lzma_raw_buffer_encode(invalid_filters, NULL,
				invalid_buf_in, LZMA_FILTER_RAW_CHUNK_SIZE,
				invalid_buf_out, &out_pos,
				LZMA_FILTER_RAW_CHUNK_SIZE),
				LZMA_OPTIONS_ERROR);
#endif
#ifdef TEST_FILTER_CHAIN_ENCODER_LZMA1
	raw_buffer_encode_and_verify(test_file_data, test_file_data_size,
				test_lzma1_raw_encoded_data,
				test_lzma1_raw_encoded_data_size,
				lzma1_filters);
#endif
#ifdef TEST_FILTER_CHAIN_ENCODER_LZMA2
	raw_buffer_encode_and_verify(test_file_data, test_file_data_size,
				test_lzma2_raw_encoded_data,
				test_lzma2_raw_encoded_data_size,
				lzma2_filters);
#endif
}


// Helper function for the test_lzma_raw_buffer_encode function
// Used to decode both LZMA1 and LZMA2 raw data and compare the
// results to precomputed text files in files/lzma_filters/
static void
raw_buffer_decode_and_verify(const uint8_t* input_data,
			size_t input_data_size,
			const uint8_t* expected_output,
			size_t expected_output_size,
			lzma_filter* filters)
{
	// Use the precomputed size to determine outbuf size
	uint8_t *out_buffer = (uint8_t*) malloc(expected_output_size);
	assert_true(out_buffer != NULL);

	size_t in_pos = 0;
	size_t out_pos = 0;

	assert_int_equal(lzma_raw_buffer_decode(filters, NULL,
				input_data, &in_pos, input_data_size,
				out_buffer, &out_pos,
				expected_output_size), LZMA_OK);

	// Compare pre-computed to encoded
	assert_n_array_equal(expected_output, out_buffer,
				expected_output_size);
	free(out_buffer);
}


static void
test_lzma_raw_buffer_decode(void)
{
#ifdef TEST_FILTER_CHAIN_DECODER_INVALID
	uint8_t invalid_buf_in[LZMA_FILTER_RAW_CHUNK_SIZE];
	uint8_t invalid_buf_out[LZMA_FILTER_RAW_CHUNK_SIZE];
	size_t out_pos = 0;
	size_t in_pos = 0;

	// First use invalid filters to be sure they force
	// the LZMA_OPTIONS_ERROR as expected
	assert_int_equal(lzma_raw_buffer_decode(invalid_filters, NULL,
				invalid_buf_in, &in_pos,
				LZMA_FILTER_RAW_CHUNK_SIZE,
				invalid_buf_out, &out_pos,
				LZMA_FILTER_RAW_CHUNK_SIZE),
				LZMA_OPTIONS_ERROR);
#endif
#ifdef TEST_FILTER_CHAIN_DECODER_LZMA1
	raw_buffer_decode_and_verify(test_lzma1_raw_encoded_data,
				test_lzma1_raw_encoded_data_size,
				test_file_data, test_file_data_size,
				lzma1_filters);
#endif
#ifdef TEST_FILTER_CHAIN_DECODER_LZMA2
	raw_buffer_decode_and_verify(test_lzma2_raw_encoded_data,
				test_lzma2_raw_encoded_data_size,
				test_file_data, test_file_data_size,
				lzma2_filters);
#endif
}


static void
test_lzma_raw_encoder_set_out_limit(void)
{
	lzma_stream strm = LZMA_STREAM_INIT;
	uint64_t uncomp_size = 0;
	// Expect an error when using a NULL stream
	assert_int_equal(lzma_raw_encoder_set_out_limit(
			NULL, &uncomp_size, LZMA_FILTER_RAW_CHUNK_SIZE),
			LZMA_PROG_ERROR);
	// Expect an error when using an unitialized stream
	assert_int_equal(lzma_raw_encoder_set_out_limit(
			&strm, &uncomp_size, LZMA_FILTER_RAW_CHUNK_SIZE),
			LZMA_PROG_ERROR);
	// Expect an error when using a NULL uncomp_size
	assert_int_equal(lzma_raw_encoder_set_out_limit(
			&strm, NULL, LZMA_FILTER_RAW_CHUNK_SIZE),
			LZMA_PROG_ERROR);

#ifdef TEST_FILTER_CHAIN_LZMA2
	// Initialize an LZMA2 raw encoder
	lzma_stream lzma2_strm = LZMA_STREAM_INIT;
	assert_int_equal(lzma_raw_encoder(&lzma2_strm, lzma2_filters),
				LZMA_OK);
	// Must error because LZMA2 filter is not supported by this function
	assert_int_equal(lzma_raw_encoder_set_out_limit(&lzma2_strm,
			&uncomp_size, LZMA_FILTER_RAW_CHUNK_SIZE),
			LZMA_OPTIONS_ERROR);
#endif

#ifdef TEST_FILTER_CHAIN_ENCODER_LZMA1
	// The encoder only works with LZMA1 as the only filter
	// so we cannot use the usual x86 -> delta -> LZMA1 chain

	// Initialize LZMA1 raw encoder
	assert_int_equal(lzma_raw_encoder(&strm, lzma1_alone_filters),
				LZMA_OK);
	// Set the output limit to LZMA_FILTER_RAW_CHUNK_SIZE
	assert_int_equal(lzma_raw_encoder_set_out_limit(&strm, &uncomp_size,
				LZMA_FILTER_RAW_CHUNK_SIZE), LZMA_OK);

	// Encode LZMA_FILTER_RAW_CHUNK_SIZE input into a buffer
	// First, create buffer with extra space in case
	// lzma_raw_encoder_set_out_limit does not work properly
	uint8_t output_buffer[LZMA_FILTER_RAW_CHUNK_SIZE + 1000];
	strm.next_in = test_file_data;
	strm.avail_in = test_file_data_size;
	strm.next_out = output_buffer;
	strm.avail_out = LZMA_FILTER_RAW_CHUNK_SIZE;

	lzma_action action = LZMA_RUN;
	while(1) {
		if(strm.avail_in == 0 || strm.avail_out == 0) {
			action = LZMA_FINISH;
		}

		lzma_ret ret = lzma_code(&strm, action);

		if(ret == LZMA_STREAM_END) {
			break;
		}

		assert_int_equal(ret, LZMA_OK);
	}

	// Output should be LZMA_FILTER_RAW_CHUNK_SIZE, not
	// the full size of the output_buffer
	assert_true(LZMA_FILTER_RAW_CHUNK_SIZE >= strm.total_out);
	// Check for correctly encoded data
	// Not checking the last 5 bytes because of the range encoder
	// flush at the end of the data
	assert_n_array_equal(test_lzma1_alone_raw_encoded_data,
			output_buffer, strm.total_out - 5);

#endif
}


static void
test_lzma_raw_decoder_uncompressed(void)
{
	lzma_stream strm = LZMA_STREAM_INIT;
	lzma_vli uncomp_size = 0;
	// Expect an error when using a NULL stream
	assert_int_equal(lzma_raw_decoder_uncompressed(NULL, uncomp_size),
			LZMA_PROG_ERROR);
	// Expect an error when using and uninitialized stream
	assert_int_equal(lzma_raw_decoder_uncompressed(&strm, uncomp_size),
			LZMA_PROG_ERROR);

#ifdef TEST_FILTER_CHAIN_LZMA2
	// Initialize an LZMA2 raw decoder
	lzma_stream lzma2_strm = LZMA_STREAM_INIT;
	assert_int_equal(lzma_raw_decoder(&lzma2_strm, lzma2_filters),
			LZMA_OK);
	// Must error because LZMA2 fitler is not supported by this function
	assert_int_equal(lzma_raw_decoder_uncompressed(&lzma2_strm,
			uncomp_size), LZMA_OPTIONS_ERROR);

#endif

#ifdef TEST_FILTER_CHAIN_LZMA1
	// First, compress test data by setting out limit
	// Repeating steps from test_lzma_raw_encoder_set_out_limit
	// instead of using global variables and coupling the tests
	// together
	lzma_stream compress_strm = LZMA_STREAM_INIT;
	assert_int_equal(lzma_raw_encoder(&compress_strm,
			lzma1_alone_filters), LZMA_OK);
	// Set the output limit to LZMA_FILTER_RAW_CHUNK_SIZE
	assert_int_equal(lzma_raw_encoder_set_out_limit(&compress_strm,
			&uncomp_size, LZMA_FILTER_RAW_CHUNK_SIZE),
			LZMA_OK);

	uint8_t compressed_buffer[LZMA_FILTER_RAW_CHUNK_SIZE + 1000];
	compress_strm.next_in = test_file_data;
	compress_strm.avail_in = test_file_data_size;
	compress_strm.next_out = compressed_buffer;
	compress_strm.avail_out = LZMA_FILTER_RAW_CHUNK_SIZE + 1000;

	lzma_action action = LZMA_RUN;
	while(1) {
		if(compress_strm.avail_in == 0 ||
				compress_strm.avail_out == 0) {
			action = LZMA_FINISH;
		}

		lzma_ret ret = lzma_code(&compress_strm, action);

		if(ret == LZMA_STREAM_END) {
			break;
		}

		assert_int_equal(ret, LZMA_OK);
	}
	assert_true(LZMA_FILTER_RAW_CHUNK_SIZE >= strm.total_out);

	// Initialize LZMA1 raw decoder
	assert_int_equal(lzma_raw_decoder(&strm, lzma1_alone_filters), LZMA_OK);
	// Set output limit from compression result
	assert_int_equal(lzma_raw_decoder_uncompressed(&strm, uncomp_size), LZMA_OK);

	uint8_t *out_buffer = (uint8_t*) malloc(uncomp_size);
	assert_true(out_buffer != NULL);

	strm.next_in = compressed_buffer;
	strm.avail_in = compress_strm.total_out;
	strm.next_out = out_buffer;
	strm.avail_out = uncomp_size;

	// Decompress recently compressed data
	while(1) {
		if(strm.avail_in == 0 || strm.avail_out == 0) {
			action = LZMA_FINISH;
		}

		lzma_ret ret = lzma_code(&strm, action);

		if(ret == LZMA_STREAM_END) {
			break;
		}

		assert_int_equal(ret, LZMA_OK);
	}
	// Amount of decompressed bytes needs to equal uncomp_size
	assert_int_equal(strm.total_out, uncomp_size);
	// Compare output with the original input data
	assert_n_array_equal(test_file_data, out_buffer, uncomp_size);
	free(out_buffer);

#endif
}


void
test_lzma_raw(void)
{
	test_fixture_start();
	// Fill in test data globals
	test_file_data_size = read_file_into_buffer(
				test_data_filename,
				&test_file_data);
	assert_true(test_file_data_size);

	test_lzma1_raw_encoded_data_size = read_file_into_buffer(
				test_lzma1_raw_encoded_filename,
				&test_lzma1_raw_encoded_data);
	assert_true(test_lzma1_raw_encoded_data_size);

	test_lzma2_raw_encoded_data_size = read_file_into_buffer(
				test_lzma2_raw_encoded_filename,
				&test_lzma2_raw_encoded_data);
	assert_true(test_lzma2_raw_encoded_data_size);

	test_lzma1_alone_raw_encoded_data_size = read_file_into_buffer(
				test_lzma1_alone_raw_encoded_filename,
				&test_lzma1_alone_raw_encoded_data);

	assert_true(test_lzma1_alone_raw_encoded_data_size);

	run_test(test_lzma_raw_encoder_memusage);
	run_test(test_lzma_raw_decoder_memusage);
	run_test(test_lzma_raw_encoder);
	run_test(test_lzma_raw_decoder);
	run_test(test_lzma_raw_buffer_encode);
	run_test(test_lzma_raw_buffer_decode);
	run_test(test_lzma_raw_encoder_set_out_limit);
	run_test(test_lzma_raw_decoder_uncompressed);

	free(test_file_data);
	free(test_lzma1_raw_encoded_data);
	free(test_lzma2_raw_encoded_data);
	free(test_lzma1_alone_raw_encoded_data);
	test_fixture_end();
}
