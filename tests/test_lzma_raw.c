///////////////////////////////////////////////////////////////////////////////
//
/// \file       test_lzma_raw.c
/// \brief      Tests liblzma raw API functions from
///             src/liblzma/api/lzma/filter.h
//
//  Author:     TODO
//
//  This file has been put into the public domain.
//  You can do whatever you want with this file.
//
///////////////////////////////////////////////////////////////////////////////

#include "liblzma_tests.h"
#include "test_utils.h"
#include "test_lzma_filter_utils.h"
#include <stdlib.h>

#define LZMA_FILTER_RAW_CHUNK_SIZE 4096

// Hardcoding expected memusage amounts in order to detect
// unexpected changes to memusage
// Used in test_lzma_raw_encoder_memusage and
// test_lzma_raw_decoder_memusage
#define EXPECTED_LZMA1_ENCODER_MEMUSAGE 63739583
#define EXPECTED_LZMA2_ENCODER_MEMUSAGE 64067431
#define EXPECTED_LZMA1_DECODER_MEMUSAGE 8455392
#define EXPECTED_LZMA2_DECODER_MEMUSAGE 8455576


static void
test_lzma_raw_encoder_memusage(void)
{
#ifdef TEST_FILTER_CHAIN_ENCODER_INVALID
	// Invalid filters should error out with UINT64_MAX
	assert_ulong_equal(lzma_raw_encoder_memusage(invalid_filters),
				UINT64_MAX);
#endif
#ifdef TEST_FILTER_CHAIN_ENCODER_LZMA1
	// Filters memusage should be non-zero and < UINT64_MAX
	uint64_t lzma1_memusage = lzma_raw_encoder_memusage(lzma1_filters);
	assert_true(lzma1_memusage > 0 && lzma1_memusage < UINT64_MAX);
	// Check against hard coded memusage value
	assert_ulong_equal(EXPECTED_LZMA1_ENCODER_MEMUSAGE, lzma1_memusage);
#endif
#ifdef TEST_FILTER_CHAIN_ENCODER_LZMA2
	uint64_t lzma2_memusage = lzma_raw_encoder_memusage(lzma2_filters);
	assert_true(lzma2_memusage > 0 && lzma2_memusage < UINT64_MAX);
	// Check against hard coded memusage value
	assert_ulong_equal(EXPECTED_LZMA2_ENCODER_MEMUSAGE, lzma2_memusage);
#endif
}


static void
test_lzma_raw_decoder_memusage(void)
{
#ifdef TEST_FILTER_CHAIN_DECODER_INVALID
	// Invalid filters should error out with UINT64_MAX
	assert_ulong_equal(lzma_raw_decoder_memusage(invalid_filters),
				UINT64_MAX);
#endif
#ifdef TEST_FILTER_CHAIN_DECODER_LZMA1
	// Filters memusage should be non-zero and < UINT64_MAX
	uint64_t lzma1_memusage = lzma_raw_decoder_memusage(lzma1_filters);
	assert_true(lzma1_memusage > 0 && lzma1_memusage < UINT64_MAX);
	// Check against hard coded memusage value
	assert_ulong_equal(EXPECTED_LZMA1_DECODER_MEMUSAGE, lzma1_memusage);
#endif
#ifdef TEST_FILTER_CHAIN_DECODER_LZMA2
	uint64_t lzma2_memusage = lzma_raw_decoder_memusage(lzma2_filters);
	assert_true(lzma2_memusage > 0 && lzma2_memusage < UINT64_MAX);
	// Check against hard coded memusage value
	assert_ulong_equal(EXPECTED_LZMA2_DECODER_MEMUSAGE, lzma2_memusage);
#endif
}


// Helper function for both test_lzma_raw_encoder and test_lzma_raw_decoder
// Applies lzma_code on data from original_filename into a buffer until
// all of the data has been processed
// Then it will compare the buffer to contents from precomputed_filename
// Files in files/lzma_filters/ contain small text files and corresponding
// LZMA1 and LZMA2 raw encoded files generated by
// the XZ command line interface
static void
raw_coder_and_verify(const char* original_filename,
			const char* precomputed_filename,
			lzma_stream *strm)
{
	// Read original file into buffer
	uint8_t *original_data = NULL;
	size_t original_size = read_file_into_buffer(
				original_filename,
				&original_data);
	assert_true(original_size);

	// Allocate raw buffer one chunk at a time
	int chunks_used = 1;
	uint8_t* raw_buffer = (uint8_t*) malloc(LZMA_FILTER_RAW_CHUNK_SIZE);
	assert_true(raw_buffer != NULL);

	strm->next_in = original_data;
	strm->avail_in = original_size;
	strm->next_out = raw_buffer;
	strm->avail_out = LZMA_FILTER_RAW_CHUNK_SIZE;

	lzma_action action = LZMA_RUN;
	// Loop until LZMA_STREAM_END or error returned
	while(1) {
		if(strm->avail_in == 0) {
			action = LZMA_FINISH;
		}

		lzma_ret ret = lzma_code(strm, action);

		if(ret == LZMA_STREAM_END) {
			break;
		}

		if(strm->avail_out == 0) {
			chunks_used++;
			raw_buffer = realloc(raw_buffer,
						chunks_used *
						LZMA_FILTER_RAW_CHUNK_SIZE);
			strm->next_out = raw_buffer +
					((chunks_used - 1) *
					LZMA_FILTER_RAW_CHUNK_SIZE);
			strm->avail_out = LZMA_FILTER_RAW_CHUNK_SIZE;
		}

		assert_int_equal(ret, LZMA_OK);
	}

	// Read pre-computed data into buffer
	uint8_t *precomputed_data = NULL;
	size_t precomputed_size = read_file_into_buffer(
			precomputed_filename,
			&precomputed_data);
	assert_true(precomputed_size);
	// Compare pre-computed to output
	assert_n_array_equal(precomputed_data, raw_buffer,
				precomputed_size);

	free(original_data);
	free(precomputed_data);
	free(raw_buffer);
}


static void
test_lzma_raw_encoder(void)
{
#ifdef TEST_FILTER_CHAIN_ENCODER_INVALID
	lzma_stream strm_error = LZMA_STREAM_INIT;
	// Verify errors are returned for invalid filters
	assert_int_equal(lzma_raw_encoder(&strm_error, invalid_filters),
						LZMA_OPTIONS_ERROR);
#endif
#ifdef TEST_FILTER_CHAIN_ENCODER_LZMA1
	// Verify initialization of LZMA1 raw encoder
	lzma_stream lzma1_raw_strm = LZMA_STREAM_INIT;
	assert_int_equal(lzma_raw_encoder(&lzma1_raw_strm, lzma1_filters),
						LZMA_OK);
	raw_coder_and_verify("files/lzma_filters/raw_original.txt",
				"files/lzma_filters/lzma1_raw",
				&lzma1_raw_strm);
#endif

#ifdef TEST_FILTER_CHAIN_ENCODER_LZMA2
	// Verify initialilzation of LZMA2 raw encoder
	lzma_stream lzma2_raw_strm = LZMA_STREAM_INIT;
	assert_int_equal(lzma_raw_encoder(&lzma2_raw_strm, lzma2_filters),
						LZMA_OK);
	raw_coder_and_verify("files/lzma_filters/raw_original.txt",
				"files/lzma_filters/lzma2_raw",
				&lzma2_raw_strm);
#endif
}


static void
test_lzma_raw_decoder(void)
{
#ifdef TEST_FILTER_CHAIN_DECODER_INVALID
	lzma_stream strm_error = LZMA_STREAM_INIT;
	// Verify errors are returned for invalid filters
	assert_int_equal(lzma_raw_decoder(&strm_error, invalid_filters),
						LZMA_OPTIONS_ERROR);
#endif
#ifdef TEST_FILTER_CHAIN_DECODER_LZMA1
	// Verify initialization of lzma1 raw decoder
	lzma_stream lzma1_raw_strm = LZMA_STREAM_INIT;
	assert_int_equal(lzma_raw_decoder(&lzma1_raw_strm, lzma1_filters),
						LZMA_OK);
	raw_coder_and_verify("files/lzma_filters/lzma1_raw",
				"files/lzma_filters/raw_original.txt",
				&lzma1_raw_strm);
#endif
#ifdef TEST_FILTER_CHAIN_DECODER_LZMA2
	// Verify initialization of lzma2 raw decoder
	lzma_stream lzma2_raw_strm = LZMA_STREAM_INIT;
	assert_int_equal(lzma_raw_decoder(&lzma2_raw_strm, lzma2_filters),
						LZMA_OK);

	raw_coder_and_verify("files/lzma_filters/lzma2_raw",
				"files/lzma_filters/raw_original.txt",
				&lzma2_raw_strm);
#endif
}


// Helper function for the test_lzma_raw_buffer_encode function
// Used to encode both LZMA1 and LZMA2 raw data and compare the
// results to precomputed files in files/lzma_filters/
static void
raw_buffer_encode_and_verify(const char* original_filename,
			const char* precomputed_filename,
			lzma_filter* filters)
{
	// Read original file into buffer
	uint8_t *original_data = NULL;
	size_t original_size = read_file_into_buffer(
				original_filename,
				&original_data);
	assert_true(original_size);

	// lzma_stream_buffer_bound should return more than what we need
	// for the raw buffer, but the extra space will not hurt
	size_t upperbound_out_buf_size =
				lzma_stream_buffer_bound(original_size);

	uint8_t* out_buffer = (uint8_t*) malloc(upperbound_out_buf_size);
	assert_true(out_buffer != NULL);
	size_t out_pos = 0;

	lzma_ret ret = lzma_raw_buffer_encode(filters, NULL,
				original_data, original_size, out_buffer,
				&out_pos, upperbound_out_buf_size);
	assert_int_equal(ret, LZMA_OK);

	// Read pre-computed data into buffer
	uint8_t *precomputed_data = NULL;
	size_t precomputed_size = read_file_into_buffer(
			precomputed_filename,
			&precomputed_data);
	assert_true(precomputed_size);
	// Compare pre-computed to encoded
	assert_n_array_equal(precomputed_data, out_buffer,
				out_pos);

	free(original_data);
	free(precomputed_data);
	free(out_buffer);
}


static void
test_lzma_raw_buffer_encode(void)
{
#ifdef TEST_FILTER_CHAIN_ENCODER_INVALID
	uint8_t invalid_buf_in[LZMA_FILTER_RAW_CHUNK_SIZE];
	uint8_t invalid_buf_out[LZMA_FILTER_RAW_CHUNK_SIZE];
	size_t out_pos = 0;
	// First use invalid filters to be sure they force
	// the LZMA_OPTIONS_ERROR as expected
	assert_int_equal(lzma_raw_buffer_encode(invalid_filters, NULL,
				invalid_buf_in, LZMA_FILTER_RAW_CHUNK_SIZE,
				invalid_buf_out, &out_pos,
				LZMA_FILTER_RAW_CHUNK_SIZE),
				LZMA_OPTIONS_ERROR);
#endif
#ifdef TEST_FILTER_CHAIN_ENCODER_LZMA1
	raw_buffer_encode_and_verify("files/lzma_filters/raw_original.txt",
				"files/lzma_filters/lzma1_raw",
				 lzma1_filters);
#endif
#ifdef TEST_FILTER_CHAIN_ENCODER_LZMA2
	raw_buffer_encode_and_verify("files/lzma_filters/raw_original.txt",
				"files/lzma_filters/lzma2_raw",
				lzma2_filters);
#endif
}


// Helper function for the test_lzma_raw_buffer_encode function
// Used to decode both LZMA1 and LZMA2 raw data and compare the
// results to precomputed text files in files/lzma_filters/
static void
raw_buffer_decode_and_verify(const char* original_filename,
			const char* precomputed_filename,
			lzma_filter* filters)
{
	// Read original file into buffer
	uint8_t *original_data = NULL;
	size_t original_size = read_file_into_buffer(
				original_filename,
				&original_data);
	assert_true(original_size);

	// Read pre-computed data into buffer
	uint8_t *precomputed_data = NULL;
	size_t precomputed_size = read_file_into_buffer(
			precomputed_filename,
			&precomputed_data);
	assert_true(precomputed_size);

	// Use the precomputed size to determine outbuf size
	uint8_t *out_buffer = (uint8_t*) malloc(precomputed_size);

	size_t in_pos = 0;
	size_t out_pos = 0;

	assert_int_equal(lzma_raw_buffer_decode(filters, NULL,
				original_data, &in_pos, original_size,
				out_buffer, &out_pos,
				precomputed_size), LZMA_OK);

	// Compare pre-computed to encoded
	assert_n_array_equal(precomputed_data, out_buffer,
				out_pos);

	free(original_data);
	free(precomputed_data);
	free(out_buffer);
}


static void
test_lzma_raw_buffer_decode(void)
{
#ifdef TEST_FILTER_CHAIN_DECODER_INVALID
	uint8_t invalid_buf_in[LZMA_FILTER_RAW_CHUNK_SIZE];
	uint8_t invalid_buf_out[LZMA_FILTER_RAW_CHUNK_SIZE];
	size_t out_pos = 0;
	size_t in_pos = 0;

	// First use invalid filters to be sure they force
	// the LZMA_OPTIONS_ERROR as expected
	assert_int_equal(lzma_raw_buffer_decode(invalid_filters, NULL,
				invalid_buf_in, &in_pos,
				LZMA_FILTER_RAW_CHUNK_SIZE,
				invalid_buf_out, &out_pos,
				LZMA_FILTER_RAW_CHUNK_SIZE),
				LZMA_OPTIONS_ERROR);
#endif
#ifdef TEST_FILTER_CHAIN_DECODER_LZMA1
	raw_buffer_decode_and_verify("files/lzma_filters/lzma1_raw",
				"files/lzma_filters/raw_original.txt",
				 lzma1_filters);
#endif
#ifdef TEST_FILTER_CHAIN_DECODER_LZMA2
	raw_buffer_decode_and_verify("files/lzma_filters/lzma2_raw",
				"files/lzma_filters/raw_original.txt",
				lzma2_filters);
#endif
}


void
test_lzma_raw(void)
{
	test_fixture_start();
	run_test(test_lzma_raw_encoder_memusage);
	run_test(test_lzma_raw_decoder_memusage);
	run_test(test_lzma_raw_encoder);
	run_test(test_lzma_raw_decoder);
	run_test(test_lzma_raw_buffer_encode);
	run_test(test_lzma_raw_buffer_decode);
	test_fixture_end();
}
